*barbar.txt*                      Nvim


                      barbar.vim    by Rom Grk


Help on barbar.vim                                                    *barbar*

1. Intro                        |barbar-intro|
2. Mappings & Commands          |barbar-mappings| |barbar-commands|
3. Highlights                   |barbar-highlights|
4. Settings                     |barbar-settings|
5. Integrations                 |barbar-integrations|

==============================================================================
1. Intro                                                        *barbar-intro*

Barbar is a tabline plugin. It's called Barbar because it deals with the bar
at the top of your window. And it does it well so it's more than a bar. Barbar.

==============================================================================
2. Mappings & Commands                     *barbar-mappings* *barbar-commands*

The plugin doesn't provide default mappings as there isn't any standard. The
list below is the mappings I use. It is recommended to use the `BufferClose`
command to close buffers instead of `bdelete` because it will not mess your
window layout.

The name of each command should be descriptive enough for you to use it.
>
    " Move to previous/next
    nnoremap <silent>    <A-,> <Cmd>BufferPrevious<CR>
    nnoremap <silent>    <A-.> <Cmd>BufferNext<CR>

    " Re-order to previous/next
    nnoremap <silent>    <A-<> <Cmd>BufferMovePrevious<CR>
    nnoremap <silent>    <A->> <Cmd>BufferMoveNext<CR>

    " Goto buffer in position...
    nnoremap <silent>    <A-1> <Cmd>BufferGoto 1<CR>
    nnoremap <silent>    <A-2> <Cmd>BufferGoto 2<CR>
    nnoremap <silent>    <A-3> <Cmd>BufferGoto 3<CR>
    nnoremap <silent>    <A-4> <Cmd>BufferGoto 4<CR>
    nnoremap <silent>    <A-5> <Cmd>BufferGoto 5<CR>
    nnoremap <silent>    <A-6> <Cmd>BufferGoto 6<CR>
    nnoremap <silent>    <A-7> <Cmd>BufferGoto 7<CR>
    nnoremap <silent>    <A-8> <Cmd>BufferGoto 8<CR>
    nnoremap <silent>    <A-9> <Cmd>BufferGoto 9<CR>
    nnoremap <silent>    <A-0> <Cmd>BufferLast<CR>

    " Pin/unpin buffer
    nnoremap <silent>    <A-p> <Cmd>BufferPin<CR>

    " Close buffer
    nnoremap <silent>    <A-c> <Cmd>BufferClose<CR>

    " Wipeout buffer
    "                          :BufferWipeout
    " Close commands
    "                          :BufferCloseAllButCurrent
    "                          :BufferCloseAllButVisible
    "                          :BufferCloseAllButPinned
    "                          :BufferCloseAllButCurrentOrPinned
    "                          :BufferCloseBuffersLeft
    "                          :BufferCloseBuffersRight

    " Magic buffer-picking mode
    nnoremap <silent> <C-p>    <Cmd>BufferPick<CR>
    nnoremap <silent> <C-p>    <Cmd>BufferPickDelete<CR>

    " Sort automatically by...
    nnoremap <silent> <Space>bb <Cmd>BufferOrderByBufferNumber<CR>
    nnoremap <silent> <Space>bd <Cmd>BufferOrderByDirectory<CR>
    nnoremap <silent> <Space>bl <Cmd>BufferOrderByLanguage<CR>
    nnoremap <silent> <Space>bw <Cmd>BufferOrderByWindowNumber<CR>

    " Other:
    " :BarbarEnable - enables barbar (enabled by default)
    " :BarbarDisable - very bad command, should never be used
<

==============================================================================
3. Highlights                                              *barbar-highlights*
~

Here are the groups that you should define if you'd like to style Barbar.

>
    let fg_target = 'red'

    let fg_current  = s:fg(['Normal'], '#efefef')
    let fg_visible  = s:fg(['TabLineSel'], '#efefef')
    let fg_inactive = s:fg(['TabLineFill'], '#888888')

    let fg_modified  = s:fg(['WarningMsg'], '#E5AB0E')
    let fg_special  = s:fg(['Special'], '#599eff')
    let fg_subtle  = s:fg(['NonText', 'Comment'], '#555555')

    let bg_current  = s:bg(['Normal'], '#000000')
    let bg_visible  = s:bg(['TabLineSel', 'Normal'], '#000000')
    let bg_inactive = s:bg(['TabLineFill', 'StatusLine'], '#000000')

    " Meaning of terms:
    "
    " format: "Buffer" + status + part
    "
    " status:
    "     *Current: current buffer
    "     *Visible: visible but not current buffer
    "    *Inactive: invisible but not current buffer
    "
    " part:
    "        *Icon: filetype icon
    "       *Index: buffer index
    "         *Mod: when modified
    "        *Sign: the separator between buffers
    "      *Target: letter in buffer-picking mode
    "
    " BufferTabpages: tabpage indicator
    " BufferTabpageFill: filler after the buffer section
    " BufferOffset: offset section, created with set_offset()

    call s:hi_all([
    \ ['BufferCurrent',        fg_current,  bg_current],
    \ ['BufferCurrentIndex',   fg_special,  bg_current],
    \ ['BufferCurrentMod',     fg_modified, bg_current],
    \ ['BufferCurrentSign',    fg_special,  bg_current],
    \ ['BufferCurrentTarget',  fg_target,   bg_current,   'bold'],
    \ ['BufferVisible',        fg_visible,  bg_visible],
    \ ['BufferVisibleIndex',   fg_visible,  bg_visible],
    \ ['BufferVisibleMod',     fg_modified, bg_visible],
    \ ['BufferVisibleSign',    fg_visible,  bg_visible],
    \ ['BufferVisibleTarget',  fg_target,   bg_visible,   'bold'],
    \ ['BufferInactive',       fg_inactive, bg_inactive],
    \ ['BufferInactiveIndex',  fg_subtle,   bg_inactive],
    \ ['BufferInactiveMod',    fg_modified, bg_inactive],
    \ ['BufferInactiveSign',   fg_subtle,   bg_inactive],
    \ ['BufferInactiveTarget', fg_target,   bg_inactive,  'bold'],
    \ ['BufferTabpages',       fg_special,  bg_inactive, 'bold'],
    \ ['BufferTabpageFill',    fg_inactive, bg_inactive],
    \ ])

    call s:hi_link([
    \ ['BufferCurrentIcon',  'BufferCurrent'],
    \ ['BufferVisibleIcon',  'BufferVisible'],
    \ ['BufferInactiveIcon', 'BufferInactive'],
    \ ['BufferOffset',       'BufferTabpageFill'],
    \ ])

    " NOTE: this is an example taken from the source, implementation of
    " s:fg(), s:bg(), s:hi_all() and s:hi_link() is left as an exercise
    " for the reader.
<

==============================================================================
4. Settings                                                  *barbar-settings*
~

                                                      *g:bufferline.animation*
`g:bufferline.animation` boolean  (default |v:true|)

  Enables animations.

                                                      *g:bufferline.auto_hide*
`g:bufferline.auto_hide`  boolean  (default |v:false|)

  Enable/disable auto-hiding the tab bar when there is a single buffer.

                                                       *g:bufferline.tabpages*
`g:bufferline.tabpages`  boolean  (default |v:true|)

  Enable/disable current/total tabpages indicator (top right corner).

                                                          *g:bufferline.icons*
`g:bufferline.icons`  table

  Controls the icons rendered on each tab. The base options are:

  buffer_index  (boolean) ~
  - Default: |v:false|
  - if `true`, show the index of the buffer with respect to the ordering of
    the buffers in the tabline.

  buffer_number  (boolean) ~
  - Default: |v:false|
  - If `true`, show the `bufnr` for the associated buffer.

  button  (false|string) ~
  - Default: `'Ôôï'`
  - The button which is clicked to close / save a buffer, or indicate that it
    is pinned. Use `false` to disable it.

  diagnostics (table<DiagnosticSeverity, table>) ~
  - Default: >
    {
       [vim.diagnostic.severity.ERROR] = {enabled = false, icon = '‚ìç '},
       [vim.diagnostic.severity.HINT] = {enabled = false, icon = 'üí°'},
       [vim.diagnostic.severity.INFO] = {enabled = false, icon = '‚ìò '},
       [vim.diagnostic.severity.WARN] = {enabled = false, icon = '‚ö†Ô∏è '},
    }
< - Enables or disables showing diagnostics in the bufferline. The options
    are:
    - `enabled`, whether this diagnostics of this severity are shown in the
      bufferline.
    - `icon`, which controls what icon accompanies the number of diagnostics.


  filetype.custom_colors  (boolean) ~
  - Default: |v:false|
  - If present, this color will be used for ALL filetype icons

  filetype.enabled  (boolean) ~
  - Default: |v:true|
  - Filetype `true`, show the `devicons` for the associated buffer's `filetype`.

  separator  (table) ~
  - Default: `{'left': '‚ñé', 'right': ''}`
  - The left-hand separator between buffers in the tabline.

  Example: >
    " Show the file icon, a left separator, and ERROR/WARN diagnostics
    let bufferline.icons = {
      \'buffer_index': v:false,
      \'buffer_number': v:false,
      \'button': 'Ôôï',
      \'diagnostics': [{'enabled': v:true}, {'enabled': v:true}],
      \'filetype': {'enabled': v:true},
      \'separator': {'left': '‚ñé'},
    \}
<

  You can also customize icons of 'modified' and pinned buffers:

  modified (table) ~
  - Default: `{'button': '‚óè'}`
  - The icons which should be used for a 'modified' buffer.
  - Supports all the base options (e.g. `buffer_index`, `filetype.enabled`,
    etc)

  pinned (table) ~
  - Default: `{'button': 'Ôì≤'}`
  - The icons which should be used for a pinned buffer.
  - Supports all the base options (e.g. `buffer_index`, `filetype.enabled`,
    etc)

  Example: >
    " Change the button only when the buffer is modified or pinned
    let bufferline.icons = {
        \'modified': {'button': '‚óè'},
        \'pinned': {'button': 'Ô§Ç'},
    \}
<

  Lastly, you can customize icons based on the visibility of a buffer:

  alternate (table) ~
  - The icons which should be used for the |alternate-file|.
  - Supports all the base options (e.g. `buffer_index`, `filetype.enabled`,
    etc) as well as `modified` and `pinned`.

  current (table) ~
  - The icons which should be used for current buffer.
  - Supports all the base options (e.g. `buffer_index`, `filetype.enabled`,
    etc) as well as `modified` and `pinned`.

  inactive (table) ~
  - Default: `{'separator': {'left': '‚ñé', 'right': ''}}`
  - The icons which should be used for |hidden-buffer|s and |inactive-buffer|s.
  - Supports all the base options (e.g. `buffer_index`, `filetype.enabled`,
    etc) as well as `modified` and `pinned`.

  visible (table) ~
  - The icons which should be used for |active-buffer|s.
  - Supports all the base options (e.g. `buffer_index`, `filetype.enabled`,
    etc) as well as `modified` and `pinned`.

  Example: >
    " Enable file icons for alternate buffers.
    " Enable buffer indices for current buffers.
    " Override the button for inactive buffers.
    " Disable buffer numbers for visible, modified buffers.
    let bufferline.icons = {
      \'alternate': {'filetype': {'enabled': v:false}},
      \'current': {'buffer_index': v:true},
      \'inactive': {'button': '√ó'},
      \'visible': {'modified': {'buffer_number': v:false}},
    \}
<

                                                *g:bufferline.insert_at_start*
`g:bufferline.insert_at_start` boolean  (default |v:false|)

  If true, new buffers appear at the start of the list. Default is to
  open after the current buffer.
  Has priority over `g:bufferline.insert_at_end`

                                                  *g:bufferline.insert_at_end*
`g:bufferline.insert_at_end`  boolean   (default |v:false|)

  If true, new buffers appear at the end of the list. Default is to
  open after the current buffer.

                                               *g:bufferline.semantic_letters*
`g:bufferline.semantic_letters`  boolean  (default |v:true|)

  If set, the letters for each buffer in buffer-pick mode will be
  assigned based on their name. Otherwise or in case all letters are
  already assigned, the behavior is to assign letters in order of
  usability (see order just below)

                                                        *g:bufferline.letters*
`g:bufferline.letters` string
           (default 'asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERUTYQP')

  New buffer letters are assigned in this order. This order is
  optimal for the qwerty keyboard layout but might need adjustement
  for other layouts.
>
    let g:bufferline.letters =
      \ 'asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERUTYQP'
<

                                                      *g:bufferline.clickable*
`g:bufferline.clickable`  boolean  (default |v:true|)

  If set, you can left-click on a tab to switch to that buffer, and
  middle-click to delete it.
>
    let g:bufferline.clickable = v:true
<

                                                     *g:bufferline.exclude_ft*
`g:bufferline.exclude_ft`  string[]  (default |v:null|)

  Excludes filetypes from appearing in the tabs.
>
    let g:bufferline.exclude_ft = ['javascript']
<

                                                   *g:bufferline.exclude_name*
`g:bufferline.exclude_name`  string[]  (default |v:null|)

  Excludes buffers matching name from appearing in the tabs.
>
    let g:bufferline.exclude_name = ['package.json']
<

                                                *g:bufferline.maximum_padding*
`g:bufferline.maximum_padding`  int  (default 4)

  Sets the maximum padding width with which to surround each tab.
>
    let g:bufferline.maximum_padding = 4
<

                                                *g:bufferline.minimum_padding*
`g:bufferline.minimum_padding`  int  (default 1)

  Sets the minimum padding width with which to surround each tab.
>
    let g:bufferline.minimum_padding = 1
<

                                                 *g:bufferline.maximum_length*
`g:bufferline.maximum_length`  int  (default 30)

  Sets the maximum buffer name length.
>
    let g:bufferline.maximum_length = 30
<

                                                  *g:bufferline.no_name_title*
`g:bufferline.no_name_title`  string  (default empty)

  Sets the name of unnamed buffers. By default format is "[Buffer X]"
  where X is the buffer number. But only a static string is accepted here.
>
    let g:bufferline.no_name_title = v:null
<

                                                           *g:bufferline.hide*
`g:bufferline.hide`  table  (default |v:false| for all)

  Sets which elements are hidden in the bufferline. Possible options are:

  - `alternate`, which controls the visibility of the alternate buffer
    (`g:bufferline.highlight.alternate` must be |v:true|);
  - `current`, which controls the visibility of the current buffer;
  - `extensions`, which controls the visibility of file extensions;
  - `inactive`, which controls the visibility of the inactive buffers; and
  - `visible`, which controls the visibility of visible buffers
    (`g:bufferline.highlight.visible` must be |v:true|).
>
    let g:bufferline.hide = {'current': v:false, 'inactive': v:true}
<

                                            *g:bufferline.highlight_alternate*
`g:bufferline.highlight_alternate`  boolean  (default |v:false|)

  Enables highlighting of alternate buffers.
>
    let g:bufferline.highlight_alternate = v:true
<

                                              *g:bufferline.highlight_visible*
`g:bufferline.highlight_visible`  boolean  (default |v:true|)

  Enables highlighting of visible buffers.
>
    let g:bufferline.highlight_visible = v:true
<

                                  *g:bufferline.highlight_inactive_file_icons*
`g:bufferline.highlight_inactive_file_icons`  boolean  (default |v:false|)

  Enables highlighting the file icons of inactive buffers.
>
    let g:bufferline.highlight_inactive_file_icons = v:true
<

                                                 *g:bufferline.focus_on_close*
`g:bufferline.focus_on_close`  "left"|"right"  (default "left")

  A buffer to this direction will be focused (if it exists) when closing the
  current buffer.
>
    let g:bufferline.focus_on_close = "left"
<

==============================================================================
5. Integrations                                          *barbar-integrations*

------------------------------------------------------------------------------
FILETREE PLUGINS

To ensure tabs begin with the shown buffer you can set an offset for the
tabline. Add this |autocmd| to your configuration: >
    vim.api.nvim_create_autocmd('FileType', {
      callback = function(tbl)
        local set_offset = require('bufferline.api').set_offset

        local bufwinid
        local last_width
        local autocmd = vim.api.nvim_create_autocmd('WinScrolled', {
          callback = function()
            bufwinid = bufwinid or vim.fn.bufwinid(tbl.buf)

            local width = vim.api.nvim_win_get_width(bufwinid)
            if width ~= last_width then
              set_offset(width, 'FileTree')
              last_width = width
            end
          end,
        })

        vim.api.nvim_create_autocmd('BufWipeout', {
          buffer = tbl.buf,
          callback = function()
            vim.api.nvim_del_autocmd(autocmd)
            set_offset(0)
          end,
          once = true,
        })
      end,
      pattern = 'NvimTree', -- or any other filetree's `ft`
    })
<

 vim:tw=78:ts=8:ft=help:norl:
